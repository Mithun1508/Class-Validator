{
  "version": 3,
  "sources": ["../../../../class-validator/test/functional/validation-options.spec.ts"],
  "sourcesContent": ["import {\n  Contains,\n  IsDefined,\n  Matches,\n  MinLength,\n  Validate,\n  ValidateNested,\n  ValidatorConstraint,\n  IsOptional,\n  IsNotEmpty,\n} from '../../src/decorator/decorators';\nimport { Validator } from '../../src/validation/Validator';\nimport {\n  registerDecorator,\n  ValidationArguments,\n  ValidationError,\n  ValidationOptions,\n  ValidatorConstraintInterface,\n} from '../../src';\n\nconst validator = new Validator();\n\ndescribe('message', () => {\n  it('should contain a custom message', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: 'String is not valid. You string must contain a hello word',\n      })\n      someProperty: string;\n    }\n\n    const model = new MyClass();\n    // TODO: Why is this commented out?\n    // model.someProperty = \"hell no world\";\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].constraints).toEqual({ contains: 'String is not valid. You string must contain a hello word' });\n    });\n  });\n\n  it('$value token should be replaced in a custom message', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: '$value is not valid. You string must contain a hello word',\n      })\n      someProperty: string;\n    }\n\n    const model = new MyClass();\n    model.someProperty = 'hell no world';\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].constraints).toEqual({\n        contains: 'hell no world is not valid. You string must contain a hello word',\n      });\n    });\n  });\n\n  it('$value token should be replaced in a custom message', () => {\n    class MyClass {\n      @MinLength(2, {\n        message: args => {\n          if (args.value.length < 2) {\n            return '$value is too short, minimum length is $constraint1 characters $property';\n          }\n        },\n      })\n      name: string;\n    }\n\n    const model = new MyClass();\n    model.name = '';\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].constraints).toEqual({ minLength: ' is too short, minimum length is 2 characters name' });\n    });\n  });\n\n  it('$constraint1 token should be replaced in a custom message', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: 'String is not valid. You string must contain a $constraint1 word',\n      })\n      someProperty: string;\n    }\n\n    const model = new MyClass();\n    model.someProperty = 'hell no world';\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].constraints).toEqual({ contains: 'String is not valid. You string must contain a hello word' });\n    });\n  });\n\n  it('$target token should be replaced in a custom message', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: '$target is not valid.',\n      })\n      someProperty: string;\n    }\n\n    const model = new MyClass();\n    model.someProperty = 'hell no world';\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].constraints).toEqual({ contains: 'MyClass is not valid.' });\n    });\n  });\n\n  it('$property token should be replaced in a custom message', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: '$property is not valid.',\n      })\n      someProperty: string;\n    }\n\n    const model = new MyClass();\n    model.someProperty = 'hell no world';\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].constraints).toEqual({ contains: 'someProperty is not valid.' });\n    });\n  });\n\n  it('should replace all token', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: '$target#$property is not valid: $value must contain a $constraint1 word',\n      })\n      someProperty: string;\n    }\n\n    const model = new MyClass();\n    model.someProperty = 'hell no world';\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].constraints).toEqual({\n        contains: 'MyClass#someProperty is not valid: hell no world must contain a hello word',\n      });\n    });\n  });\n});\n\ndescribe('each', () => {\n  describe('Array', () => {\n    it('should apply validation to each item in the array', () => {\n      class MyClass {\n        @Contains('hello', {\n          each: true,\n        })\n        someProperty: string[];\n      }\n\n      const model = new MyClass();\n      model.someProperty = ['hell no world', 'hello', 'helo world', 'hello world', 'hello dear friend'];\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ contains: 'each value in someProperty must contain a hello string' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class to array items (but not array itself)', () => {\n      @ValidatorConstraint({ name: 'customIsNotArrayConstraint', async: false })\n      class CustomIsNotArrayConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean {\n          return !(value instanceof Array);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomIsNotArrayConstraint, {\n          each: true,\n        })\n        someArrayOfNonArrayItems: string[];\n      }\n\n      const model = new MyClass();\n      model.someArrayOfNonArrayItems = ['not array', 'also not array', 'not array at all'];\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('should apply validation via custom constraint class with synchronous logic to each item in the array', () => {\n      @ValidatorConstraint({ name: 'customContainsHelloConstraint', async: false })\n      class CustomContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean {\n          return !(value instanceof Array) && String(value).includes('hello');\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: string[];\n      }\n\n      const model = new MyClass();\n      model.someProperty = ['hell no world', 'hello', 'helo world', 'hello world', 'hello dear friend'];\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class with async logic to each item in the array', () => {\n      @ValidatorConstraint({ name: 'customAsyncContainsHelloConstraint', async: true })\n      class CustomAsyncContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): Promise<boolean> {\n          const isValid = !(value instanceof Array) && String(value).includes('hello');\n          return Promise.resolve(isValid);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomAsyncContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: string[];\n      }\n\n      const model = new MyClass();\n      model.someProperty = ['hell no world', 'hello', 'helo world', 'hello world', 'hello dear friend'];\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customAsyncContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class with mixed (synchronous + async) logic to each item in the array', () => {\n      @ValidatorConstraint({ name: 'customMixedContainsHelloConstraint', async: true })\n      class CustomMixedContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean | Promise<boolean> {\n          const isValid = !(value instanceof Array) && String(value).includes('hello');\n          return isValid ? isValid : Promise.resolve(isValid);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomMixedContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: string[];\n      }\n\n      const model = new MyClass();\n      model.someProperty = ['hell no world', 'hello', 'helo world', 'hello world', 'hello dear friend'];\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customMixedContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n  });\n\n  describe('Set', () => {\n    it('should apply validation to each item in the Set', () => {\n      class MyClass {\n        @Contains('hello', {\n          each: true,\n        })\n        someProperty: Set<string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Set<string>([\n        'hell no world',\n        'hello',\n        'helo world',\n        'hello world',\n        'hello dear friend',\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ contains: 'each value in someProperty must contain a hello string' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class to Set items (but not Set itself)', () => {\n      @ValidatorConstraint({ name: 'customIsNotSetConstraint', async: false })\n      class CustomIsNotSetConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean {\n          return !(value instanceof Set);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomIsNotSetConstraint, {\n          each: true,\n        })\n        someSetOfNonSetItems: Set<string>;\n      }\n\n      const model = new MyClass();\n      model.someSetOfNonSetItems = new Set<string>(['not array', 'also not array', 'not array at all']);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('should apply validation via custom constraint class with synchronous logic to each item in the Set', () => {\n      @ValidatorConstraint({ name: 'customContainsHelloConstraint', async: false })\n      class CustomContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean {\n          return !(value instanceof Set) && String(value).includes('hello');\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: Set<string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Set<string>([\n        'hell no world',\n        'hello',\n        'helo world',\n        'hello world',\n        'hello dear friend',\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class with async logic to each item in the Set', () => {\n      @ValidatorConstraint({ name: 'customAsyncContainsHelloConstraint', async: true })\n      class CustomAsyncContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): Promise<boolean> {\n          const isValid = !(value instanceof Set) && String(value).includes('hello');\n          return Promise.resolve(isValid);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomAsyncContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: Set<string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Set<string>([\n        'hell no world',\n        'hello',\n        'helo world',\n        'hello world',\n        'hello dear friend',\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customAsyncContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class with mixed (synchronous + async) logic to each item in the Set', () => {\n      @ValidatorConstraint({ name: 'customMixedContainsHelloConstraint', async: true })\n      class CustomMixedContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean | Promise<boolean> {\n          const isValid = !(value instanceof Set) && String(value).includes('hello');\n          return isValid ? isValid : Promise.resolve(isValid);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomMixedContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: Set<string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Set<string>([\n        'hell no world',\n        'hello',\n        'helo world',\n        'hello world',\n        'hello dear friend',\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customMixedContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n  });\n\n  describe('Map', () => {\n    it('should apply validation to each item in the Map', () => {\n      class MyClass {\n        @Contains('hello', {\n          each: true,\n        })\n        someProperty: Map<string, string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Map<string, string>([\n        ['key1', 'hell no world'],\n        ['key2', 'hello'],\n        ['key3', 'helo world'],\n        ['key4', 'hello world'],\n        ['key5', 'hello dear friend'],\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ contains: 'each value in someProperty must contain a hello string' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class to Map items (but not Map itself)', () => {\n      @ValidatorConstraint({ name: 'customIsNotMapConstraint', async: false })\n      class CustomIsNotMapConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean {\n          return !(value instanceof Map);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomIsNotMapConstraint, {\n          each: true,\n        })\n        someArrayOfNonArrayItems: Map<string, string>;\n      }\n\n      const model = new MyClass();\n      model.someArrayOfNonArrayItems = new Map<string, string>([\n        ['key1', 'not array'],\n        ['key2', 'also not array'],\n        ['key3', 'not array at all'],\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('should apply validation via custom constraint class with synchronous logic to each item in the Map', () => {\n      @ValidatorConstraint({ name: 'customContainsHelloConstraint', async: false })\n      class CustomContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean {\n          return !(value instanceof Map) && String(value).includes('hello');\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: Map<string, string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Map<string, string>([\n        ['key1', 'hell no world'],\n        ['key2', 'hello'],\n        ['key3', 'helo world'],\n        ['key4', 'hello world'],\n        ['key5', 'hello dear friend'],\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class with async logic to each item in the Map', () => {\n      @ValidatorConstraint({ name: 'customAsyncContainsHelloConstraint', async: true })\n      class CustomAsyncContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): Promise<boolean> {\n          const isValid = !(value instanceof Map) && String(value).includes('hello');\n          return Promise.resolve(isValid);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomAsyncContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: Map<string, string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Map<string, string>([\n        ['key1', 'hell no world'],\n        ['key2', 'hello'],\n        ['key3', 'helo world'],\n        ['key4', 'hello world'],\n        ['key5', 'hello dear friend'],\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customAsyncContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n\n    it('should apply validation via custom constraint class with mixed (synchronous + async) logic to each item in the Map', () => {\n      @ValidatorConstraint({ name: 'customMixedContainsHelloConstraint', async: true })\n      class CustomMixedContainsHelloConstraint implements ValidatorConstraintInterface {\n        validate(value: any): boolean | Promise<boolean> {\n          const isValid = !(value instanceof Map) && String(value).includes('hello');\n          return isValid ? isValid : Promise.resolve(isValid);\n        }\n      }\n\n      class MyClass {\n        @Validate(CustomMixedContainsHelloConstraint, {\n          each: true,\n        })\n        someProperty: Map<string, string>;\n      }\n\n      const model = new MyClass();\n      model.someProperty = new Map<string, string>([\n        ['key1', 'hell no world'],\n        ['key2', 'hello'],\n        ['key3', 'helo world'],\n        ['key4', 'hello world'],\n        ['key5', 'hello dear friend'],\n      ]);\n      return validator.validate(model).then(errors => {\n        expect(errors.length).toEqual(1);\n        expect(errors[0].constraints).toEqual({ customMixedContainsHelloConstraint: '' });\n        expect(errors[0].value).toEqual(model.someProperty);\n        expect(errors[0].target).toEqual(model);\n        expect(errors[0].property).toEqual('someProperty');\n      });\n    });\n  });\n});\n\ndescribe('groups', () => {\n  function expectTitleContains(error: ValidationError): void {\n    expect(error.constraints).toEqual({ contains: 'title must contain a hello string' });\n  }\n\n  function expectTextContains(error: ValidationError): void {\n    expect(error.constraints).toEqual({ contains: 'text must contain a bye string' });\n  }\n\n  class MyClass {\n    @Contains('hello', {\n      groups: ['title-validation'],\n    })\n    title: string;\n\n    @Contains('bye', {\n      groups: ['text-validation'],\n    })\n    text: string;\n  }\n\n  const validTitle = new MyClass();\n  validTitle.title = 'hello world';\n  validTitle.text = 'hello world';\n\n  const validText = new MyClass();\n  validText.title = 'bye world';\n  validText.text = 'bye world';\n\n  const validBoth = new MyClass();\n  validBoth.title = 'hello world';\n  validBoth.text = 'bye world';\n\n  const validNone = new MyClass();\n  validNone.title = 'bye world';\n  validNone.text = 'hello world';\n\n  describe('should validate only properties of the given group: title-validation', () => {\n    it('with valid title', () => {\n      return validator.validate(validTitle, { groups: ['title-validation'] }).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('with valid text', () => {\n      return validator.validate(validText, { groups: ['title-validation'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTitleContains(errors[0]);\n      });\n    });\n\n    it('with both valid', () => {\n      return validator.validate(validBoth, { groups: ['title-validation'] }).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('with none valid', () => {\n      return validator.validate(validNone, { groups: ['title-validation'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTitleContains(errors[0]);\n      });\n    });\n  });\n\n  describe('should validate only properties of the given group: text-validation', () => {\n    it('with valid title', () => {\n      return validator.validate(validTitle, { groups: ['text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTextContains(errors[0]);\n      });\n    });\n\n    it('with valid text', () => {\n      return validator.validate(validText, { groups: ['text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('with both valid', () => {\n      return validator.validate(validBoth, { groups: ['text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('with none valid', () => {\n      return validator.validate(validNone, { groups: ['text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTextContains(errors[0]);\n      });\n    });\n  });\n\n  describe('should validate only properties of the given groups: both groups', () => {\n    it('with valid title', () => {\n      return validator.validate(validTitle, { groups: ['title-validation', 'text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTextContains(errors[0]);\n      });\n    });\n\n    it('with valid text', () => {\n      return validator.validate(validText, { groups: ['title-validation', 'text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTitleContains(errors[0]);\n      });\n    });\n\n    it('with both valid', () => {\n      return validator.validate(validBoth, { groups: ['title-validation', 'text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('with none valid', () => {\n      return validator.validate(validNone, { groups: ['title-validation', 'text-validation'] }).then(errors => {\n        expect(errors.length).toEqual(2);\n        expectTitleContains(errors[0]);\n        expectTextContains(errors[1]);\n      });\n    });\n  });\n\n  describe('should validate all if no group is given', () => {\n    it('with valid title', () => {\n      // todo: all or without? what is better expected behaviour?\n      return validator.validate(validTitle).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTextContains(errors[0]);\n      });\n    });\n\n    it('with valid text', () => {\n      // todo: all or without? what is better expected behaviour?\n      return validator.validate(validText).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTitleContains(errors[0]);\n      });\n    });\n\n    it('with both valid', () => {\n      // todo: all or without? what is better expected behaviour?\n      return validator.validate(validBoth).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('with none valid', () => {\n      // todo: all or without? what is better expected behaviour?\n      return validator.validate(validNone).then(errors => {\n        expect(errors.length).toEqual(2);\n        expectTitleContains(errors[0]);\n        expectTextContains(errors[1]);\n      });\n    });\n  });\n\n  describe('should validate all groups if empty group array is given', () => {\n    it('with valid title', () => {\n      return validator.validate(validTitle, { groups: [] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTextContains(errors[0]);\n      });\n    });\n\n    it('with valid text', () => {\n      return validator.validate(validText, { groups: [] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTitleContains(errors[0]);\n      });\n    });\n\n    it('with both valid', () => {\n      return validator.validate(validBoth, { groups: [] }).then(errors => {\n        expect(errors.length).toEqual(0);\n      });\n    });\n\n    it('with none valid', () => {\n      return validator.validate(validNone, { groups: [] }).then(errors => {\n        expect(errors.length).toEqual(2);\n        expectTitleContains(errors[0]);\n        expectTextContains(errors[1]);\n      });\n    });\n  });\n\n  describe('multiple groups per property', () => {\n    class MyClass {\n      @Contains('hello', { groups: ['contains'] })\n      @Matches(/.*stranger.*/, { groups: ['matches'] })\n      title: string;\n    }\n\n    function expectTitleMatches(error: ValidationError): void {\n      expect(error.constraints).toEqual({ matches: 'title must match /.*stranger.*/ regular expression' });\n    }\n\n    const validContains = new MyClass();\n    validContains.title = 'hello';\n\n    const validMatches = new MyClass();\n    validMatches.title = 'stranger';\n\n    const validBoth = new MyClass();\n    validBoth.title = 'hello stranger';\n\n    const validNone = new MyClass();\n    validNone.title = 'howdy rowdy';\n\n    describe('group: contains', () => {\n      it('with valid contains', () => {\n        return validator.validate(validContains, { groups: ['contains'] }).then(errors => {\n          expect(errors.length).toEqual(0);\n        });\n      });\n\n      it('with valid matches', () => {\n        return validator.validate(validMatches, { groups: ['contains'] }).then(errors => {\n          expect(errors.length).toEqual(1);\n          expectTitleContains(errors[0]);\n        });\n      });\n\n      it('with valid both', () => {\n        return validator.validate(validBoth, { groups: ['contains'] }).then(errors => {\n          expect(errors.length).toEqual(0);\n        });\n      });\n\n      it('with valid none', () => {\n        return validator.validate(validNone, { groups: ['contains'] }).then(errors => {\n          expect(errors.length).toEqual(1);\n          expectTitleContains(errors[0]);\n        });\n      });\n    });\n\n    describe('group: matches', () => {\n      it('with valid contains', () => {\n        return validator.validate(validContains, { groups: ['matches'] }).then(errors => {\n          expect(errors.length).toEqual(1);\n          expectTitleMatches(errors[0]);\n        });\n      });\n\n      it('with valid matches', () => {\n        return validator.validate(validMatches, { groups: ['matches'] }).then(errors => {\n          expect(errors.length).toEqual(0);\n        });\n      });\n\n      it('with valid both', () => {\n        return validator.validate(validBoth, { groups: ['matches'] }).then(errors => {\n          expect(errors.length).toEqual(0);\n        });\n      });\n\n      it('with valid none', () => {\n        return validator.validate(validNone, { groups: ['matches'] }).then(errors => {\n          expect(errors.length).toEqual(1);\n          expectTitleMatches(errors[0]);\n        });\n      });\n    });\n\n    describe('groups: contains & matches', () => {\n      it('with valid contains', () => {\n        return validator.validate(validContains, { groups: ['contains', 'matches'] }).then(errors => {\n          expect(errors.length).toEqual(1);\n          expectTitleMatches(errors[0]);\n        });\n      });\n\n      it('with valid matches', () => {\n        return validator.validate(validMatches, { groups: ['contains', 'matches'] }).then(errors => {\n          expect(errors.length).toEqual(1);\n          expectTitleContains(errors[0]);\n        });\n      });\n\n      it('with valid both', () => {\n        return validator.validate(validBoth, { groups: ['contains', 'matches'] }).then(errors => {\n          expect(errors.length).toEqual(0);\n        });\n      });\n\n      it('with valid none', () => {\n        return validator.validate(validNone, { groups: ['contains', 'matches'] }).then(errors => {\n          expect(errors.length).toEqual(1);\n          expect(errors[0].constraints).toEqual({\n            contains: 'title must contain a hello string',\n            matches: 'title must match /.*stranger.*/ regular expression',\n          });\n        });\n      });\n    });\n  });\n\n  describe('ValidationOptions.always', function () {\n    class MyClass {\n      @Contains('noOptions')\n      noOptions: string;\n\n      @Contains('groupA', {\n        groups: ['A'],\n      })\n      groupA: string;\n\n      @Contains('alwaysFalse', {\n        always: false,\n      })\n      alwaysFalse: string;\n\n      @Contains('alwaysTrue', {\n        always: true,\n      })\n      alwaysTrue: string;\n    }\n\n    const model1 = new MyClass();\n    model1.noOptions = 'XXX';\n    model1.groupA = 'groupA';\n    model1.alwaysFalse = 'alwaysFalse';\n    model1.alwaysTrue = 'alwaysTrue';\n\n    const model2 = new MyClass();\n    model2.noOptions = 'noOptions';\n    model2.groupA = 'XXX';\n    model2.alwaysFalse = 'alwaysFalse';\n    model2.alwaysTrue = 'alwaysTrue';\n\n    const model3 = new MyClass();\n    model3.noOptions = 'noOptions';\n    model3.groupA = 'groupA';\n    model3.alwaysFalse = 'XXX';\n    model3.alwaysTrue = 'alwaysTrue';\n\n    const model4 = new MyClass();\n    model4.noOptions = 'noOptions';\n    model4.groupA = 'groupA';\n    model4.alwaysFalse = 'alwaysFalse';\n    model4.alwaysTrue = 'XXX';\n\n    it('should validate decorator without options', function () {\n      return validator.validate(model1, { always: true, groups: ['A'] }).then(errors => {\n        expect(errors).toHaveLength(1);\n      });\n    });\n\n    it('should not validate decorator with groups if validating without matching groups', function () {\n      return validator.validate(model2, { always: true, groups: ['B'] }).then(errors => {\n        expect(errors).toHaveLength(0);\n      });\n    });\n\n    it('should not validate decorator with always set to false', function () {\n      return validator.validate(model3, { always: true, groups: ['A'] }).then(errors => {\n        expect(errors).toHaveLength(0);\n      });\n    });\n\n    it('should validate decorator with always set to true', function () {\n      return validator.validate(model4, { always: true, groups: ['A'] }).then(errors => {\n        expect(errors).toHaveLength(1);\n      });\n    });\n  });\n\n  describe('strictGroups', function () {\n    class MyClass {\n      @Contains('hello', {\n        groups: ['A'],\n      })\n      title: string;\n    }\n\n    const model1 = new MyClass();\n\n    it('should ignore decorators with groups if validating without groups', function () {\n      return validator.validate(model1, { strictGroups: true }).then(errors => {\n        expect(errors).toHaveLength(0);\n      });\n    });\n\n    it('should ignore decorators with groups if validating with empty groups array', function () {\n      return validator.validate(model1, { strictGroups: true, groups: [] }).then(errors => {\n        expect(errors).toHaveLength(0);\n      });\n    });\n\n    it('should include decorators with groups if validating with matching groups', function () {\n      return validator.validate(model1, { strictGroups: true, groups: ['A'] }).then(errors => {\n        expect(errors).toHaveLength(1);\n        expectTitleContains(errors[0]);\n      });\n    });\n\n    it('should not include decorators with groups if validating with different groups', function () {\n      return validator.validate(model1, { strictGroups: true, groups: ['B'] }).then(errors => {\n        expect(errors).toHaveLength(0);\n      });\n    });\n  });\n\n  describe('always', () => {\n    class MyClass {\n      @Contains('hello', {\n        groups: ['sometimes'],\n      })\n      title: string;\n\n      @Contains('bye', {\n        groups: ['always'],\n        always: true,\n      })\n      text: string;\n    }\n\n    const model = new MyClass();\n\n    it('should always validate a marked field even if another group is specified', () => {\n      return validator.validate(model, { groups: ['sometimes'] }).then(errors => {\n        expect(errors.length).toEqual(2);\n        expectTitleContains(errors[0]);\n        expectTextContains(errors[1]);\n      });\n    });\n\n    it('should always validate a marked field if its group is specified also (doubly enabled)', () => {\n      return validator.validate(model, { groups: ['always'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectTextContains(errors[0]);\n      });\n    });\n\n    it('should always validate *all* fields if group is not specified', () => {\n      return validator.validate(model, { groups: undefined }).then(errors => {\n        expect(errors.length).toEqual(2);\n        expectTitleContains(errors[0]);\n        expectTextContains(errors[1]);\n      });\n    });\n\n    it('should always validate *all* fields if groups array is empty', () => {\n      return validator.validate(model, { groups: [] }).then(errors => {\n        expect(errors.length).toEqual(2);\n        expectTitleContains(errors[0]);\n        expectTextContains(errors[1]);\n      });\n    });\n  });\n\n  describe('groups - nested', () => {\n    class Nested {\n      @Contains('hello', {\n        groups: ['always'],\n        always: true,\n      })\n      text: string;\n    }\n\n    class Root {\n      @ValidateNested({ groups: ['always'], always: true })\n      always = new Nested();\n\n      @ValidateNested({ groups: ['sometimes'] })\n      sometimes = new Nested();\n\n      @ValidateNested({ groups: ['other'] })\n      other = new Nested();\n    }\n\n    const model = new Root();\n\n    function expectChildConstraint(error: ValidationError, childName: string): void {\n      expect(error.property).toEqual(childName);\n      expect(error.children.length).toEqual(1);\n      expect(error.children[0].property).toEqual('text');\n      expect(error.children[0].constraints).toEqual({ contains: 'text must contain a hello string' });\n    }\n\n    it('should validate all children if no group is given', () => {\n      return validator.validate(model, { groups: undefined }).then(errors => {\n        expect(errors.length).toEqual(3);\n        expectChildConstraint(errors[0], 'always');\n        expectChildConstraint(errors[1], 'sometimes');\n        expectChildConstraint(errors[2], 'other');\n      });\n    });\n\n    it('should validate only the given group + always', () => {\n      return validator.validate(model, { groups: ['sometimes'] }).then(errors => {\n        expect(errors.length).toEqual(2);\n        expectChildConstraint(errors[0], 'always');\n        expectChildConstraint(errors[1], 'sometimes');\n      });\n    });\n\n    it('should validate only the given group + always', () => {\n      return validator.validate(model, { groups: ['always'] }).then(errors => {\n        expect(errors.length).toEqual(1);\n        expectChildConstraint(errors[0], 'always');\n      });\n    });\n  });\n});\n\ndescribe('context', () => {\n  it('should map context', () => {\n    function IsLongerThan(property: string, validationOptions?: ValidationOptions) {\n      return function (object: object, propertyName: string): void {\n        registerDecorator({\n          target: object.constructor,\n          propertyName: propertyName,\n          options: validationOptions,\n          constraints: [property],\n          name: 'isLongerThan',\n          validator: {\n            validate(value: any, args: ValidationArguments): boolean {\n              const [relatedPropertyName] = args.constraints;\n              const relatedValue = (args.object as any)[relatedPropertyName];\n              if (relatedValue === undefined || relatedValue === null) return true;\n\n              return (\n                typeof value === 'string' && typeof relatedValue === 'string' && value.length > relatedValue.length\n              );\n            },\n          },\n        });\n      };\n    }\n\n    class MyClass {\n      @Contains('hello', {\n        message: 'String is not valid. You string must contain a hello word',\n        context: {\n          hi: 'there',\n        },\n      })\n      someProperty: string;\n\n      @Contains('bye', {\n        message: 'String is not valid. You string must contain a bye word',\n        context: {\n          bye: 'now',\n        },\n      })\n      someOtherProperty: string;\n\n      @IsDefined({\n        context: {\n          foo: 'bar',\n        },\n      })\n      requiredProperty: string;\n\n      @IsLongerThan('lastName', {\n        context: { baz: 'qux' },\n        message: '$property must be longer then $constraint1. Given value: $value',\n      })\n      firstName: string;\n\n      lastName: string;\n    }\n\n    const model = new MyClass();\n    model.firstName = 'Short';\n    model.lastName = 'LongerThanFirstName';\n\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(4);\n      expect(errors[0].contexts['contains']).toEqual({ hi: 'there' });\n      expect(errors[1].contexts['contains']).toEqual({ bye: 'now' });\n      expect(errors[2].contexts['isDefined']).toEqual({ foo: 'bar' });\n      expect(errors[3].contexts['isLongerThan']).toEqual({ baz: 'qux' });\n    });\n  });\n\n  it('should map multiple context on a single property for different constraints', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: 'String is not valid. You string must contain a hello word',\n        context: {\n          hi: 'there',\n        },\n      })\n      @MinLength(20, {\n        context: {\n          whats: 'up',\n        },\n      })\n      someProperty: string;\n    }\n\n    const model = new MyClass();\n    model.someProperty = 'bippity';\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(1);\n      expect(errors[0].contexts['contains']).toEqual({ hi: 'there' });\n      expect(errors[0].contexts['minLength']).toEqual({ whats: 'up' });\n    });\n  });\n\n  it('should not map no context', () => {\n    class MyClass {\n      @Contains('hello', {\n        message: 'String is not valid. You string must contain a hello word',\n      })\n      someProperty: string;\n\n      @Contains('bye', {\n        message: 'String is not valid. You string must contain a bye word',\n        context: {\n          bye: 'now',\n        },\n      })\n      someOtherProperty: string;\n    }\n\n    const model = new MyClass();\n    // model.someProperty = \"hell no world\";\n    return validator.validate(model).then(errors => {\n      expect(errors.length).toEqual(2);\n      expect(errors[0].contexts).toBeUndefined();\n      expect(errors[1].contexts['contains']).toEqual({ bye: 'now' });\n    });\n  });\n\n  it('should stop at first error.', () => {\n    class MyClass {\n      @IsDefined({\n        message: 'isDefined',\n      })\n      @Contains('hello', {\n        message: 'String is not valid. You string must contain a hello word',\n      })\n      sameProperty: string;\n    }\n\n    const model = new MyClass();\n    return validator.validate(model, { stopAtFirstError: true }).then(errors => {\n      console.log();\n      expect(errors.length).toEqual(1);\n      expect(Object.keys(errors[0].constraints).length).toBe(1);\n      expect(errors[0].constraints['isDefined']).toBe('isDefined');\n    });\n  });\n});\n"],
  "mappings": ";;;;;;;;;;;;AAAA,wBAUO;AACP,uBAA0B;AAC1B,iBAMO;AAEP,MAAM,YAAY,IAAI,2BAAU;AAEhC,SAAS,WAAW,MAAM;AACxB,KAAG,mCAAmC,MAAM;AAC1C,UAAM,QAAQ;AAAA,IAKd;AADE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OAHG,QAIJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAG1B,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,4DAA4D,CAAC;AAAA,IACjH,CAAC;AAAA,EACH,CAAC;AAED,KAAG,uDAAuD,MAAM;AAC9D,UAAM,QAAQ;AAAA,IAKd;AADE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OAHG,QAIJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,eAAe;AACrB,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,WAAW,EAAE,QAAQ;AAAA,QACpC,UAAU;AAAA,MACZ,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,KAAG,uDAAuD,MAAM;AAC9D,UAAM,QAAQ;AAAA,IASd;AADE;AAAA,UAPC,6BAAU,GAAG;AAAA,QACZ,SAAS,UAAQ;AACf,cAAI,KAAK,MAAM,SAAS,GAAG;AACzB,mBAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF,CAAC;AAAA,OAPG,QAQJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,OAAO;AACb,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,WAAW,qDAAqD,CAAC;AAAA,IAC3G,CAAC;AAAA,EACH,CAAC;AAED,KAAG,6DAA6D,MAAM;AACpE,UAAM,QAAQ;AAAA,IAKd;AADE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OAHG,QAIJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,eAAe;AACrB,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,4DAA4D,CAAC;AAAA,IACjH,CAAC;AAAA,EACH,CAAC;AAED,KAAG,wDAAwD,MAAM;AAC/D,UAAM,QAAQ;AAAA,IAKd;AADE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OAHG,QAIJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,eAAe;AACrB,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,wBAAwB,CAAC;AAAA,IAC7E,CAAC;AAAA,EACH,CAAC;AAED,KAAG,0DAA0D,MAAM;AACjE,UAAM,QAAQ;AAAA,IAKd;AADE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OAHG,QAIJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,eAAe;AACrB,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,6BAA6B,CAAC;AAAA,IAClF,CAAC;AAAA,EACH,CAAC;AAED,KAAG,4BAA4B,MAAM;AACnC,UAAM,QAAQ;AAAA,IAKd;AADE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OAHG,QAIJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,eAAe;AACrB,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,WAAW,EAAE,QAAQ;AAAA,QACpC,UAAU;AAAA,MACZ,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH,CAAC;AAED,SAAS,QAAQ,MAAM;AACrB,WAAS,SAAS,MAAM;AACtB,OAAG,qDAAqD,MAAM;AAC5D,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,SAAS;AAAA,UACjB,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,CAAC,iBAAiB,SAAS,cAAc,eAAe,mBAAmB;AAChG,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,yDAAyD,CAAC;AAC5G,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,6FAA6F,MAAM;AAEpG,UAAM,6BAAN,MAAyE;AAAA,QACvE,SAAS,OAAqB;AAC5B,iBAAO,EAAE,iBAAiB;AAAA,QAC5B;AAAA,MACF;AAJM,mCAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,8BAA8B,OAAO,MAAM,CAAC;AAAA,SACnE;AAMN,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,4BAA4B;AAAA,UACpC,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,2BAA2B,CAAC,aAAa,kBAAkB,kBAAkB;AACnF,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,wGAAwG,MAAM;AAE/G,UAAM,gCAAN,MAA4E;AAAA,QAC1E,SAAS,OAAqB;AAC5B,iBAAO,EAAE,iBAAiB,UAAU,OAAO,KAAK,EAAE,SAAS,OAAO;AAAA,QACpE;AAAA,MACF;AAJM,sCAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,iCAAiC,OAAO,MAAM,CAAC;AAAA,SACtE;AAMN,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,+BAA+B;AAAA,UACvC,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,CAAC,iBAAiB,SAAS,cAAc,eAAe,mBAAmB;AAChG,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,+BAA+B,GAAG,CAAC;AAC3E,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,kGAAkG,MAAM;AAEzG,UAAM,qCAAN,MAAiF;AAAA,QAC/E,SAAS,OAA8B;AACrC,gBAAM,UAAU,EAAE,iBAAiB,UAAU,OAAO,KAAK,EAAE,SAAS,OAAO;AAC3E,iBAAO,QAAQ,QAAQ,OAAO;AAAA,QAChC;AAAA,MACF;AALM,2CAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,sCAAsC,OAAO,KAAK,CAAC;AAAA,SAC1E;AAON,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,oCAAoC;AAAA,UAC5C,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,CAAC,iBAAiB,SAAS,cAAc,eAAe,mBAAmB;AAChG,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,oCAAoC,GAAG,CAAC;AAChF,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,wHAAwH,MAAM;AAE/H,UAAM,qCAAN,MAAiF;AAAA,QAC/E,SAAS,OAAwC;AAC/C,gBAAM,UAAU,EAAE,iBAAiB,UAAU,OAAO,KAAK,EAAE,SAAS,OAAO;AAC3E,iBAAO,UAAU,UAAU,QAAQ,QAAQ,OAAO;AAAA,QACpD;AAAA,MACF;AALM,2CAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,sCAAsC,OAAO,KAAK,CAAC;AAAA,SAC1E;AAON,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,oCAAoC;AAAA,UAC5C,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,CAAC,iBAAiB,SAAS,cAAc,eAAe,mBAAmB;AAChG,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,oCAAoC,GAAG,CAAC;AAChF,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,OAAO,MAAM;AACpB,OAAG,mDAAmD,MAAM;AAC1D,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,SAAS;AAAA,UACjB,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAY;AAAA,QACnC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,yDAAyD,CAAC;AAC5G,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,yFAAyF,MAAM;AAEhG,UAAM,2BAAN,MAAuE;AAAA,QACrE,SAAS,OAAqB;AAC5B,iBAAO,EAAE,iBAAiB;AAAA,QAC5B;AAAA,MACF;AAJM,iCAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,4BAA4B,OAAO,MAAM,CAAC;AAAA,SACjE;AAMN,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,0BAA0B;AAAA,UAClC,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,uBAAuB,oBAAI,IAAY,CAAC,aAAa,kBAAkB,kBAAkB,CAAC;AAChG,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,sGAAsG,MAAM;AAE7G,UAAM,gCAAN,MAA4E;AAAA,QAC1E,SAAS,OAAqB;AAC5B,iBAAO,EAAE,iBAAiB,QAAQ,OAAO,KAAK,EAAE,SAAS,OAAO;AAAA,QAClE;AAAA,MACF;AAJM,sCAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,iCAAiC,OAAO,MAAM,CAAC;AAAA,SACtE;AAMN,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,+BAA+B;AAAA,UACvC,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAY;AAAA,QACnC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,+BAA+B,GAAG,CAAC;AAC3E,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,gGAAgG,MAAM;AAEvG,UAAM,qCAAN,MAAiF;AAAA,QAC/E,SAAS,OAA8B;AACrC,gBAAM,UAAU,EAAE,iBAAiB,QAAQ,OAAO,KAAK,EAAE,SAAS,OAAO;AACzE,iBAAO,QAAQ,QAAQ,OAAO;AAAA,QAChC;AAAA,MACF;AALM,2CAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,sCAAsC,OAAO,KAAK,CAAC;AAAA,SAC1E;AAON,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,oCAAoC;AAAA,UAC5C,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAY;AAAA,QACnC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,oCAAoC,GAAG,CAAC;AAChF,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,sHAAsH,MAAM;AAE7H,UAAM,qCAAN,MAAiF;AAAA,QAC/E,SAAS,OAAwC;AAC/C,gBAAM,UAAU,EAAE,iBAAiB,QAAQ,OAAO,KAAK,EAAE,SAAS,OAAO;AACzE,iBAAO,UAAU,UAAU,QAAQ,QAAQ,OAAO;AAAA,QACpD;AAAA,MACF;AALM,2CAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,sCAAsC,OAAO,KAAK,CAAC;AAAA,SAC1E;AAON,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,oCAAoC;AAAA,UAC5C,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAY;AAAA,QACnC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,oCAAoC,GAAG,CAAC;AAChF,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,OAAO,MAAM;AACpB,OAAG,mDAAmD,MAAM;AAC1D,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,SAAS;AAAA,UACjB,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAoB;AAAA,QAC3C,CAAC,QAAQ,eAAe;AAAA,QACxB,CAAC,QAAQ,OAAO;AAAA,QAChB,CAAC,QAAQ,YAAY;AAAA,QACrB,CAAC,QAAQ,aAAa;AAAA,QACtB,CAAC,QAAQ,mBAAmB;AAAA,MAC9B,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,yDAAyD,CAAC;AAC5G,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,yFAAyF,MAAM;AAEhG,UAAM,2BAAN,MAAuE;AAAA,QACrE,SAAS,OAAqB;AAC5B,iBAAO,EAAE,iBAAiB;AAAA,QAC5B;AAAA,MACF;AAJM,iCAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,4BAA4B,OAAO,MAAM,CAAC;AAAA,SACjE;AAMN,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,0BAA0B;AAAA,UAClC,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,2BAA2B,oBAAI,IAAoB;AAAA,QACvD,CAAC,QAAQ,WAAW;AAAA,QACpB,CAAC,QAAQ,gBAAgB;AAAA,QACzB,CAAC,QAAQ,kBAAkB;AAAA,MAC7B,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,sGAAsG,MAAM;AAE7G,UAAM,gCAAN,MAA4E;AAAA,QAC1E,SAAS,OAAqB;AAC5B,iBAAO,EAAE,iBAAiB,QAAQ,OAAO,KAAK,EAAE,SAAS,OAAO;AAAA,QAClE;AAAA,MACF;AAJM,sCAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,iCAAiC,OAAO,MAAM,CAAC;AAAA,SACtE;AAMN,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,+BAA+B;AAAA,UACvC,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAoB;AAAA,QAC3C,CAAC,QAAQ,eAAe;AAAA,QACxB,CAAC,QAAQ,OAAO;AAAA,QAChB,CAAC,QAAQ,YAAY;AAAA,QACrB,CAAC,QAAQ,aAAa;AAAA,QACtB,CAAC,QAAQ,mBAAmB;AAAA,MAC9B,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,+BAA+B,GAAG,CAAC;AAC3E,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,gGAAgG,MAAM;AAEvG,UAAM,qCAAN,MAAiF;AAAA,QAC/E,SAAS,OAA8B;AACrC,gBAAM,UAAU,EAAE,iBAAiB,QAAQ,OAAO,KAAK,EAAE,SAAS,OAAO;AACzE,iBAAO,QAAQ,QAAQ,OAAO;AAAA,QAChC;AAAA,MACF;AALM,2CAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,sCAAsC,OAAO,KAAK,CAAC;AAAA,SAC1E;AAON,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,oCAAoC;AAAA,UAC5C,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAoB;AAAA,QAC3C,CAAC,QAAQ,eAAe;AAAA,QACxB,CAAC,QAAQ,OAAO;AAAA,QAChB,CAAC,QAAQ,YAAY;AAAA,QACrB,CAAC,QAAQ,aAAa;AAAA,QACtB,CAAC,QAAQ,mBAAmB;AAAA,MAC9B,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,oCAAoC,GAAG,CAAC;AAChF,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAED,OAAG,sHAAsH,MAAM;AAE7H,UAAM,qCAAN,MAAiF;AAAA,QAC/E,SAAS,OAAwC;AAC/C,gBAAM,UAAU,EAAE,iBAAiB,QAAQ,OAAO,KAAK,EAAE,SAAS,OAAO;AACzE,iBAAO,UAAU,UAAU,QAAQ,QAAQ,OAAO;AAAA,QACpD;AAAA,MACF;AALM,2CAAN;AAAA,YADC,uCAAoB,EAAE,MAAM,sCAAsC,OAAO,KAAK,CAAC;AAAA,SAC1E;AAON,YAAM,QAAQ;AAAA,MAKd;AADE;AAAA,YAHC,4BAAS,oCAAoC;AAAA,UAC5C,MAAM;AAAA,QACR,CAAC;AAAA,SAHG,QAIJ;AAGF,YAAM,QAAQ,IAAI,QAAQ;AAC1B,YAAM,eAAe,oBAAI,IAAoB;AAAA,QAC3C,CAAC,QAAQ,eAAe;AAAA,QACxB,CAAC,QAAQ,OAAO;AAAA,QAChB,CAAC,QAAQ,YAAY;AAAA,QACrB,CAAC,QAAQ,aAAa;AAAA,QACtB,CAAC,QAAQ,mBAAmB;AAAA,MAC9B,CAAC;AACD,aAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,eAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,oCAAoC,GAAG,CAAC;AAChF,eAAO,OAAO,GAAG,KAAK,EAAE,QAAQ,MAAM,YAAY;AAClD,eAAO,OAAO,GAAG,MAAM,EAAE,QAAQ,KAAK;AACtC,eAAO,OAAO,GAAG,QAAQ,EAAE,QAAQ,cAAc;AAAA,MACnD,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH,CAAC;AAED,SAAS,UAAU,MAAM;AACvB,WAAS,oBAAoB,OAA8B;AACzD,WAAO,MAAM,WAAW,EAAE,QAAQ,EAAE,UAAU,oCAAoC,CAAC;AAAA,EACrF;AAEA,WAAS,mBAAmB,OAA8B;AACxD,WAAO,MAAM,WAAW,EAAE,QAAQ,EAAE,UAAU,iCAAiC,CAAC;AAAA,EAClF;AAEA,QAAM,QAAQ;AAAA,EAUd;AANE;AAAA,QAHC,4BAAS,SAAS;AAAA,MACjB,QAAQ,CAAC,kBAAkB;AAAA,IAC7B,CAAC;AAAA,KAHG,QAIJ;AAKA;AAAA,QAHC,4BAAS,OAAO;AAAA,MACf,QAAQ,CAAC,iBAAiB;AAAA,IAC5B,CAAC;AAAA,KARG,QASJ;AAGF,QAAM,aAAa,IAAI,QAAQ;AAC/B,aAAW,QAAQ;AACnB,aAAW,OAAO;AAElB,QAAM,YAAY,IAAI,QAAQ;AAC9B,YAAU,QAAQ;AAClB,YAAU,OAAO;AAEjB,QAAM,YAAY,IAAI,QAAQ;AAC9B,YAAU,QAAQ;AAClB,YAAU,OAAO;AAEjB,QAAM,YAAY,IAAI,QAAQ;AAC9B,YAAU,QAAQ;AAClB,YAAU,OAAO;AAEjB,WAAS,wEAAwE,MAAM;AACrF,OAAG,oBAAoB,MAAM;AAC3B,aAAO,UAAU,SAAS,YAAY,EAAE,QAAQ,CAAC,kBAAkB,EAAE,CAAC,EAAE,KAAK,YAAU;AACrF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,kBAAkB,EAAE,CAAC,EAAE,KAAK,YAAU;AACpF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,kBAAkB,EAAE,CAAC,EAAE,KAAK,YAAU;AACpF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,kBAAkB,EAAE,CAAC,EAAE,KAAK,YAAU;AACpF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,uEAAuE,MAAM;AACpF,OAAG,oBAAoB,MAAM;AAC3B,aAAO,UAAU,SAAS,YAAY,EAAE,QAAQ,CAAC,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACpF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACnF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACnF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACnF,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,oEAAoE,MAAM;AACjF,OAAG,oBAAoB,MAAM;AAC3B,aAAO,UAAU,SAAS,YAAY,EAAE,QAAQ,CAAC,oBAAoB,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACxG,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,oBAAoB,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACvG,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,oBAAoB,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACvG,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,oBAAoB,iBAAiB,EAAE,CAAC,EAAE,KAAK,YAAU;AACvG,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAC7B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,4CAA4C,MAAM;AACzD,OAAG,oBAAoB,MAAM;AAE3B,aAAO,UAAU,SAAS,UAAU,EAAE,KAAK,YAAU;AACnD,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAE1B,aAAO,UAAU,SAAS,SAAS,EAAE,KAAK,YAAU;AAClD,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAE1B,aAAO,UAAU,SAAS,SAAS,EAAE,KAAK,YAAU;AAClD,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAE1B,aAAO,UAAU,SAAS,SAAS,EAAE,KAAK,YAAU;AAClD,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAC7B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,4DAA4D,MAAM;AACzE,OAAG,oBAAoB,MAAM;AAC3B,aAAO,UAAU,SAAS,YAAY,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,YAAU;AACnE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,YAAU;AAClE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,YAAU;AAClE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,MACjC,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mBAAmB,MAAM;AAC1B,aAAO,UAAU,SAAS,WAAW,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,YAAU;AAClE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAC7B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,gCAAgC,MAAM;AAC7C,UAAMA,SAAQ;AAAA,IAId;AADE;AAAA,UAFC,4BAAS,SAAS,EAAE,QAAQ,CAAC,UAAU,EAAE,CAAC;AAAA,UAC1C,2BAAQ,gBAAgB,EAAE,QAAQ,CAAC,SAAS,EAAE,CAAC;AAAA,OAF5CA,SAGJ;AAGF,aAAS,mBAAmB,OAA8B;AACxD,aAAO,MAAM,WAAW,EAAE,QAAQ,EAAE,SAAS,qDAAqD,CAAC;AAAA,IACrG;AAEA,UAAM,gBAAgB,IAAIA,SAAQ;AAClC,kBAAc,QAAQ;AAEtB,UAAM,eAAe,IAAIA,SAAQ;AACjC,iBAAa,QAAQ;AAErB,UAAMC,aAAY,IAAID,SAAQ;AAC9B,IAAAC,WAAU,QAAQ;AAElB,UAAMC,aAAY,IAAIF,SAAQ;AAC9B,IAAAE,WAAU,QAAQ;AAElB,aAAS,mBAAmB,MAAM;AAChC,SAAG,uBAAuB,MAAM;AAC9B,eAAO,UAAU,SAAS,eAAe,EAAE,QAAQ,CAAC,UAAU,EAAE,CAAC,EAAE,KAAK,YAAU;AAChF,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,QACjC,CAAC;AAAA,MACH,CAAC;AAED,SAAG,sBAAsB,MAAM;AAC7B,eAAO,UAAU,SAAS,cAAc,EAAE,QAAQ,CAAC,UAAU,EAAE,CAAC,EAAE,KAAK,YAAU;AAC/E,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,8BAAoB,OAAO,EAAE;AAAA,QAC/B,CAAC;AAAA,MACH,CAAC;AAED,SAAG,mBAAmB,MAAM;AAC1B,eAAO,UAAU,SAASD,YAAW,EAAE,QAAQ,CAAC,UAAU,EAAE,CAAC,EAAE,KAAK,YAAU;AAC5E,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,QACjC,CAAC;AAAA,MACH,CAAC;AAED,SAAG,mBAAmB,MAAM;AAC1B,eAAO,UAAU,SAASC,YAAW,EAAE,QAAQ,CAAC,UAAU,EAAE,CAAC,EAAE,KAAK,YAAU;AAC5E,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,8BAAoB,OAAO,EAAE;AAAA,QAC/B,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAED,aAAS,kBAAkB,MAAM;AAC/B,SAAG,uBAAuB,MAAM;AAC9B,eAAO,UAAU,SAAS,eAAe,EAAE,QAAQ,CAAC,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AAC/E,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,6BAAmB,OAAO,EAAE;AAAA,QAC9B,CAAC;AAAA,MACH,CAAC;AAED,SAAG,sBAAsB,MAAM;AAC7B,eAAO,UAAU,SAAS,cAAc,EAAE,QAAQ,CAAC,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AAC9E,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,QACjC,CAAC;AAAA,MACH,CAAC;AAED,SAAG,mBAAmB,MAAM;AAC1B,eAAO,UAAU,SAASD,YAAW,EAAE,QAAQ,CAAC,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AAC3E,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,QACjC,CAAC;AAAA,MACH,CAAC;AAED,SAAG,mBAAmB,MAAM;AAC1B,eAAO,UAAU,SAASC,YAAW,EAAE,QAAQ,CAAC,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AAC3E,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,6BAAmB,OAAO,EAAE;AAAA,QAC9B,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAED,aAAS,8BAA8B,MAAM;AAC3C,SAAG,uBAAuB,MAAM;AAC9B,eAAO,UAAU,SAAS,eAAe,EAAE,QAAQ,CAAC,YAAY,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AAC3F,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,6BAAmB,OAAO,EAAE;AAAA,QAC9B,CAAC;AAAA,MACH,CAAC;AAED,SAAG,sBAAsB,MAAM;AAC7B,eAAO,UAAU,SAAS,cAAc,EAAE,QAAQ,CAAC,YAAY,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AAC1F,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,8BAAoB,OAAO,EAAE;AAAA,QAC/B,CAAC;AAAA,MACH,CAAC;AAED,SAAG,mBAAmB,MAAM;AAC1B,eAAO,UAAU,SAASD,YAAW,EAAE,QAAQ,CAAC,YAAY,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AACvF,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,QACjC,CAAC;AAAA,MACH,CAAC;AAED,SAAG,mBAAmB,MAAM;AAC1B,eAAO,UAAU,SAASC,YAAW,EAAE,QAAQ,CAAC,YAAY,SAAS,EAAE,CAAC,EAAE,KAAK,YAAU;AACvF,iBAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,iBAAO,OAAO,GAAG,WAAW,EAAE,QAAQ;AAAA,YACpC,UAAU;AAAA,YACV,SAAS;AAAA,UACX,CAAC;AAAA,QACH,CAAC;AAAA,MACH,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,4BAA4B,WAAY;AAC/C,UAAMF,SAAQ;AAAA,IAkBd;AAhBE;AAAA,UADC,4BAAS,WAAW;AAAA,OADjBA,SAEJ;AAKA;AAAA,UAHC,4BAAS,UAAU;AAAA,QAClB,QAAQ,CAAC,GAAG;AAAA,MACd,CAAC;AAAA,OANGA,SAOJ;AAKA;AAAA,UAHC,4BAAS,eAAe;AAAA,QACvB,QAAQ;AAAA,MACV,CAAC;AAAA,OAXGA,SAYJ;AAKA;AAAA,UAHC,4BAAS,cAAc;AAAA,QACtB,QAAQ;AAAA,MACV,CAAC;AAAA,OAhBGA,SAiBJ;AAGF,UAAM,SAAS,IAAIA,SAAQ;AAC3B,WAAO,YAAY;AACnB,WAAO,SAAS;AAChB,WAAO,cAAc;AACrB,WAAO,aAAa;AAEpB,UAAM,SAAS,IAAIA,SAAQ;AAC3B,WAAO,YAAY;AACnB,WAAO,SAAS;AAChB,WAAO,cAAc;AACrB,WAAO,aAAa;AAEpB,UAAM,SAAS,IAAIA,SAAQ;AAC3B,WAAO,YAAY;AACnB,WAAO,SAAS;AAChB,WAAO,cAAc;AACrB,WAAO,aAAa;AAEpB,UAAM,SAAS,IAAIA,SAAQ;AAC3B,WAAO,YAAY;AACnB,WAAO,SAAS;AAChB,WAAO,cAAc;AACrB,WAAO,aAAa;AAEpB,OAAG,6CAA6C,WAAY;AAC1D,aAAO,UAAU,SAAS,QAAQ,EAAE,QAAQ,MAAM,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,YAAU;AAChF,eAAO,MAAM,EAAE,aAAa,CAAC;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,mFAAmF,WAAY;AAChG,aAAO,UAAU,SAAS,QAAQ,EAAE,QAAQ,MAAM,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,YAAU;AAChF,eAAO,MAAM,EAAE,aAAa,CAAC;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,0DAA0D,WAAY;AACvE,aAAO,UAAU,SAAS,QAAQ,EAAE,QAAQ,MAAM,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,YAAU;AAChF,eAAO,MAAM,EAAE,aAAa,CAAC;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,qDAAqD,WAAY;AAClE,aAAO,UAAU,SAAS,QAAQ,EAAE,QAAQ,MAAM,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,YAAU;AAChF,eAAO,MAAM,EAAE,aAAa,CAAC;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,gBAAgB,WAAY;AACnC,UAAMA,SAAQ;AAAA,IAKd;AADE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,QAAQ,CAAC,GAAG;AAAA,MACd,CAAC;AAAA,OAHGA,SAIJ;AAGF,UAAM,SAAS,IAAIA,SAAQ;AAE3B,OAAG,qEAAqE,WAAY;AAClF,aAAO,UAAU,SAAS,QAAQ,EAAE,cAAc,KAAK,CAAC,EAAE,KAAK,YAAU;AACvE,eAAO,MAAM,EAAE,aAAa,CAAC;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,8EAA8E,WAAY;AAC3F,aAAO,UAAU,SAAS,QAAQ,EAAE,cAAc,MAAM,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,YAAU;AACnF,eAAO,MAAM,EAAE,aAAa,CAAC;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,4EAA4E,WAAY;AACzF,aAAO,UAAU,SAAS,QAAQ,EAAE,cAAc,MAAM,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,YAAU;AACtF,eAAO,MAAM,EAAE,aAAa,CAAC;AAC7B,4BAAoB,OAAO,EAAE;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,iFAAiF,WAAY;AAC9F,aAAO,UAAU,SAAS,QAAQ,EAAE,cAAc,MAAM,QAAQ,CAAC,GAAG,EAAE,CAAC,EAAE,KAAK,YAAU;AACtF,eAAO,MAAM,EAAE,aAAa,CAAC;AAAA,MAC/B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,UAAU,MAAM;AACvB,UAAMA,SAAQ;AAAA,IAWd;AAPE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,QAAQ,CAAC,WAAW;AAAA,MACtB,CAAC;AAAA,OAHGA,SAIJ;AAMA;AAAA,UAJC,4BAAS,OAAO;AAAA,QACf,QAAQ,CAAC,QAAQ;AAAA,QACjB,QAAQ;AAAA,MACV,CAAC;AAAA,OATGA,SAUJ;AAGF,UAAM,QAAQ,IAAIA,SAAQ;AAE1B,OAAG,4EAA4E,MAAM;AACnF,aAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,CAAC,WAAW,EAAE,CAAC,EAAE,KAAK,YAAU;AACzE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAC7B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,yFAAyF,MAAM;AAChG,aAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,CAAC,QAAQ,EAAE,CAAC,EAAE,KAAK,YAAU;AACtE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,iEAAiE,MAAM;AACxE,aAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,OAAU,CAAC,EAAE,KAAK,YAAU;AACrE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAC7B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAED,OAAG,gEAAgE,MAAM;AACvE,aAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,CAAC,EAAE,CAAC,EAAE,KAAK,YAAU;AAC9D,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,4BAAoB,OAAO,EAAE;AAC7B,2BAAmB,OAAO,EAAE;AAAA,MAC9B,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AAED,WAAS,mBAAmB,MAAM;AAChC,UAAM,OAAO;AAAA,IAMb;AADE;AAAA,UAJC,4BAAS,SAAS;AAAA,QACjB,QAAQ,CAAC,QAAQ;AAAA,QACjB,QAAQ;AAAA,MACV,CAAC;AAAA,OAJG,OAKJ;AAGF,UAAM,KAAK;AAAA,MAAX;AAEE,sBAAS,IAAI,OAAO;AAGpB,yBAAY,IAAI,OAAO;AAGvB,qBAAQ,IAAI,OAAO;AAAA;AAAA,IACrB;AAPE;AAAA,UADC,kCAAe,EAAE,QAAQ,CAAC,QAAQ,GAAG,QAAQ,KAAK,CAAC;AAAA,OADhD,KAEJ;AAGA;AAAA,UADC,kCAAe,EAAE,QAAQ,CAAC,WAAW,EAAE,CAAC;AAAA,OAJrC,KAKJ;AAGA;AAAA,UADC,kCAAe,EAAE,QAAQ,CAAC,OAAO,EAAE,CAAC;AAAA,OAPjC,KAQJ;AAGF,UAAM,QAAQ,IAAI,KAAK;AAEvB,aAAS,sBAAsB,OAAwB,WAAyB;AAC9E,aAAO,MAAM,QAAQ,EAAE,QAAQ,SAAS;AACxC,aAAO,MAAM,SAAS,MAAM,EAAE,QAAQ,CAAC;AACvC,aAAO,MAAM,SAAS,GAAG,QAAQ,EAAE,QAAQ,MAAM;AACjD,aAAO,MAAM,SAAS,GAAG,WAAW,EAAE,QAAQ,EAAE,UAAU,mCAAmC,CAAC;AAAA,IAChG;AAEA,OAAG,qDAAqD,MAAM;AAC5D,aAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,OAAU,CAAC,EAAE,KAAK,YAAU;AACrE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,8BAAsB,OAAO,IAAI,QAAQ;AACzC,8BAAsB,OAAO,IAAI,WAAW;AAC5C,8BAAsB,OAAO,IAAI,OAAO;AAAA,MAC1C,CAAC;AAAA,IACH,CAAC;AAED,OAAG,iDAAiD,MAAM;AACxD,aAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,CAAC,WAAW,EAAE,CAAC,EAAE,KAAK,YAAU;AACzE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,8BAAsB,OAAO,IAAI,QAAQ;AACzC,8BAAsB,OAAO,IAAI,WAAW;AAAA,MAC9C,CAAC;AAAA,IACH,CAAC;AAED,OAAG,iDAAiD,MAAM;AACxD,aAAO,UAAU,SAAS,OAAO,EAAE,QAAQ,CAAC,QAAQ,EAAE,CAAC,EAAE,KAAK,YAAU;AACtE,eAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,8BAAsB,OAAO,IAAI,QAAQ;AAAA,MAC3C,CAAC;AAAA,IACH,CAAC;AAAA,EACH,CAAC;AACH,CAAC;AAED,SAAS,WAAW,MAAM;AACxB,KAAG,sBAAsB,MAAM;AAC7B,aAAS,aAAa,UAAkB,mBAAuC;AAC7E,aAAO,SAAU,QAAgB,cAA4B;AAC3D,0CAAkB;AAAA,UAChB,QAAQ,OAAO;AAAA,UACf;AAAA,UACA,SAAS;AAAA,UACT,aAAa,CAAC,QAAQ;AAAA,UACtB,MAAM;AAAA,UACN,WAAW;AAAA,YACT,SAAS,OAAY,MAAoC;AACvD,oBAAM,CAAC,mBAAmB,IAAI,KAAK;AACnC,oBAAM,eAAgB,KAAK,OAAe;AAC1C,kBAAI,iBAAiB,UAAa,iBAAiB;AAAM,uBAAO;AAEhE,qBACE,OAAO,UAAU,YAAY,OAAO,iBAAiB,YAAY,MAAM,SAAS,aAAa;AAAA,YAEjG;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAEA,UAAM,QAAQ;AAAA,IA+Bd;AAxBE;AAAA,UANC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,QACT,SAAS;AAAA,UACP,IAAI;AAAA,QACN;AAAA,MACF,CAAC;AAAA,OANG,QAOJ;AAQA;AAAA,UANC,4BAAS,OAAO;AAAA,QACf,SAAS;AAAA,QACT,SAAS;AAAA,UACP,KAAK;AAAA,QACP;AAAA,MACF,CAAC;AAAA,OAdG,QAeJ;AAOA;AAAA,UALC,6BAAU;AAAA,QACT,SAAS;AAAA,UACP,KAAK;AAAA,QACP;AAAA,MACF,CAAC;AAAA,OArBG,QAsBJ;AAMA;AAAA,MAJC,aAAa,YAAY;AAAA,QACxB,SAAS,EAAE,KAAK,MAAM;AAAA,QACtB,SAAS;AAAA,MACX,CAAC;AAAA,OA3BG,QA4BJ;AAKF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,YAAY;AAClB,UAAM,WAAW;AAEjB,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,SAAS,WAAW,EAAE,QAAQ,EAAE,IAAI,QAAQ,CAAC;AAC9D,aAAO,OAAO,GAAG,SAAS,WAAW,EAAE,QAAQ,EAAE,KAAK,MAAM,CAAC;AAC7D,aAAO,OAAO,GAAG,SAAS,YAAY,EAAE,QAAQ,EAAE,KAAK,MAAM,CAAC;AAC9D,aAAO,OAAO,GAAG,SAAS,eAAe,EAAE,QAAQ,EAAE,KAAK,MAAM,CAAC;AAAA,IACnE,CAAC;AAAA,EACH,CAAC;AAED,KAAG,8EAA8E,MAAM;AACrF,UAAM,QAAQ;AAAA,IAad;AADE;AAAA,UAXC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,QACT,SAAS;AAAA,UACP,IAAI;AAAA,QACN;AAAA,MACF,CAAC;AAAA,UACA,6BAAU,IAAI;AAAA,QACb,SAAS;AAAA,UACP,OAAO;AAAA,QACT;AAAA,MACF,CAAC;AAAA,OAXG,QAYJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,UAAM,eAAe;AACrB,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,SAAS,WAAW,EAAE,QAAQ,EAAE,IAAI,QAAQ,CAAC;AAC9D,aAAO,OAAO,GAAG,SAAS,YAAY,EAAE,QAAQ,EAAE,OAAO,KAAK,CAAC;AAAA,IACjE,CAAC;AAAA,EACH,CAAC;AAED,KAAG,6BAA6B,MAAM;AACpC,UAAM,QAAQ;AAAA,IAad;AATE;AAAA,UAHC,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OAHG,QAIJ;AAQA;AAAA,UANC,4BAAS,OAAO;AAAA,QACf,SAAS;AAAA,QACT,SAAS;AAAA,UACP,KAAK;AAAA,QACP;AAAA,MACF,CAAC;AAAA,OAXG,QAYJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAE1B,WAAO,UAAU,SAAS,KAAK,EAAE,KAAK,YAAU;AAC9C,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,GAAG,QAAQ,EAAE,cAAc;AACzC,aAAO,OAAO,GAAG,SAAS,WAAW,EAAE,QAAQ,EAAE,KAAK,MAAM,CAAC;AAAA,IAC/D,CAAC;AAAA,EACH,CAAC;AAED,KAAG,+BAA+B,MAAM;AACtC,UAAM,QAAQ;AAAA,IAQd;AADE;AAAA,UANC,6BAAU;AAAA,QACT,SAAS;AAAA,MACX,CAAC;AAAA,UACA,4BAAS,SAAS;AAAA,QACjB,SAAS;AAAA,MACX,CAAC;AAAA,OANG,QAOJ;AAGF,UAAM,QAAQ,IAAI,QAAQ;AAC1B,WAAO,UAAU,SAAS,OAAO,EAAE,kBAAkB,KAAK,CAAC,EAAE,KAAK,YAAU;AAC1E,cAAQ,IAAI;AACZ,aAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,aAAO,OAAO,KAAK,OAAO,GAAG,WAAW,EAAE,MAAM,EAAE,KAAK,CAAC;AACxD,aAAO,OAAO,GAAG,YAAY,YAAY,EAAE,KAAK,WAAW;AAAA,IAC7D,CAAC;AAAA,EACH,CAAC;AACH,CAAC;",
  "names": ["MyClass", "validBoth", "validNone"]
}

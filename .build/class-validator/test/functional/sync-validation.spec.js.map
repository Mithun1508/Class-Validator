{
  "version": 3,
  "sources": ["../../../../class-validator/test/functional/sync-validation.spec.ts"],
  "sourcesContent": ["import { Validator } from '../../src/validation/Validator';\nimport { ValidationArguments } from '../../src/validation/ValidationArguments';\nimport { registerDecorator } from '../../src/register-decorator';\nimport { ValidationOptions } from '../../src/decorator/ValidationOptions';\nimport { ValidatorConstraint, Validate, IsNotEmpty } from '../../src/decorator/decorators';\nimport { ValidatorConstraintInterface } from '../../src/validation/ValidatorConstraintInterface';\n\nconst validator = new Validator();\n\ndescribe('sync validation should ignore async validation constraints', () => {\n  @ValidatorConstraint({ name: 'isShortenThan', async: true })\n  class IsShortenThanConstraint implements ValidatorConstraintInterface {\n    validate(value: any, args: ValidationArguments): Promise<boolean> {\n      return Promise.resolve(false);\n    }\n  }\n\n  function IsLonger(property: string, validationOptions?: ValidationOptions) {\n    return function (object: object, propertyName: string): void {\n      registerDecorator({\n        target: object.constructor,\n        propertyName: propertyName,\n        options: validationOptions,\n        constraints: [property],\n        async: true,\n        name: 'isLonger',\n        validator: {\n          validate(value: any, args: ValidationArguments): Promise<boolean> {\n            return Promise.resolve(false);\n          },\n        },\n      });\n    };\n  }\n\n  class SecondClass {\n    @IsLonger('lastName')\n    firstName: string;\n\n    @Validate(IsShortenThanConstraint)\n    lastName: string;\n\n    @IsNotEmpty({ message: 'name should not be empty' })\n    name: string;\n\n    @IsNotEmpty()\n    alwaysWithValue: string = 'this field always has a value';\n  }\n\n  it('should ignore async validations and validate only sync validation types', () => {\n    expect.assertions(1);\n    const model = new SecondClass();\n    model.firstName = 'such validation may lead';\n    model.firstName = 'to recursion';\n    model.name = 'Umed';\n    const errors = validator.validateSync(model);\n    expect(errors.length).toEqual(0);\n  });\n\n  it('should ignore async validations and validate only sync validation types', () => {\n    expect.assertions(2);\n    const model = new SecondClass();\n    model.firstName = 'such validation may lead';\n    model.firstName = 'to recursion';\n    model.name = '';\n    const errors = validator.validateSync(model);\n    expect(errors.length).toEqual(1);\n    expect(errors[0].constraints).toEqual({ isNotEmpty: 'name should not be empty' });\n  });\n});\n"],
  "mappings": ";;;;;;;;;;;;AAAA,uBAA0B;AAE1B,gCAAkC;AAElC,wBAA0D;AAG1D,MAAM,YAAY,IAAI,2BAAU;AAEhC,SAAS,8DAA8D,MAAM;AAE3E,MAAM,0BAAN,MAAsE;AAAA,IACpE,SAAS,OAAY,MAA6C;AAChE,aAAO,QAAQ,QAAQ,KAAK;AAAA,IAC9B;AAAA,EACF;AAJM,4BAAN;AAAA,QADC,uCAAoB,EAAE,MAAM,iBAAiB,OAAO,KAAK,CAAC;AAAA,KACrD;AAMN,WAAS,SAAS,UAAkB,mBAAuC;AACzE,WAAO,SAAU,QAAgB,cAA4B;AAC3D,uDAAkB;AAAA,QAChB,QAAQ,OAAO;AAAA,QACf;AAAA,QACA,SAAS;AAAA,QACT,aAAa,CAAC,QAAQ;AAAA,QACtB,OAAO;AAAA,QACP,MAAM;AAAA,QACN,WAAW;AAAA,UACT,SAAS,OAAY,MAA6C;AAChE,mBAAO,QAAQ,QAAQ,KAAK;AAAA,UAC9B;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,YAAY;AAAA,IAAlB;AAWE,6BAA0B;AAAA;AAAA,EAC5B;AAVE;AAAA,IADC,SAAS,UAAU;AAAA,KADhB,YAEJ;AAGA;AAAA,QADC,4BAAS,uBAAuB;AAAA,KAJ7B,YAKJ;AAGA;AAAA,QADC,8BAAW,EAAE,SAAS,2BAA2B,CAAC;AAAA,KAP/C,YAQJ;AAGA;AAAA,QADC,8BAAW;AAAA,KAVR,YAWJ;AAGF,KAAG,2EAA2E,MAAM;AAClF,WAAO,WAAW,CAAC;AACnB,UAAM,QAAQ,IAAI,YAAY;AAC9B,UAAM,YAAY;AAClB,UAAM,YAAY;AAClB,UAAM,OAAO;AACb,UAAM,SAAS,UAAU,aAAa,KAAK;AAC3C,WAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAAA,EACjC,CAAC;AAED,KAAG,2EAA2E,MAAM;AAClF,WAAO,WAAW,CAAC;AACnB,UAAM,QAAQ,IAAI,YAAY;AAC9B,UAAM,YAAY;AAClB,UAAM,YAAY;AAClB,UAAM,OAAO;AACb,UAAM,SAAS,UAAU,aAAa,KAAK;AAC3C,WAAO,OAAO,MAAM,EAAE,QAAQ,CAAC;AAC/B,WAAO,OAAO,GAAG,WAAW,EAAE,QAAQ,EAAE,YAAY,2BAA2B,CAAC;AAAA,EAClF,CAAC;AACH,CAAC;",
  "names": []
}

{
  "version": 3,
  "sources": ["../../../../class-validator/src/validation/ValidationExecutor.ts"],
  "sourcesContent": ["import { Validator } from './Validator';\nimport { ValidationError } from './ValidationError';\nimport { ValidationMetadata } from '../metadata/ValidationMetadata';\nimport { ValidatorOptions } from './ValidatorOptions';\nimport { ValidationTypes } from './ValidationTypes';\nimport { ConstraintMetadata } from '../metadata/ConstraintMetadata';\nimport { ValidationArguments } from './ValidationArguments';\nimport { ValidationUtils } from './ValidationUtils';\nimport { isPromise, convertToArray } from '../utils';\nimport { getMetadataStorage } from '../metadata/MetadataStorage';\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  awaitingPromises: Promise<any>[] = [];\n  ignoreAsyncValidations: boolean = false;\n\n  // -------------------------------------------------------------------------\n  // Private Properties\n  // -------------------------------------------------------------------------\n\n  private metadataStorage = getMetadataStorage();\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(private validator: Validator, private validatorOptions?: ValidatorOptions) {}\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  execute(object: object, targetSchema: string, validationErrors: ValidationError[]): void {\n    /**\n     * If there is no metadata registered it means possibly the dependencies are not flatterned and\n     * more than one instance is used.\n     *\n     * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n     */\n    if (!this.metadataStorage.hasValidationMetaData && this.validatorOptions?.enableDebugMessages === true) {\n      console.warn(\n        `No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`\n      );\n    }\n\n    const groups = this.validatorOptions ? this.validatorOptions.groups : undefined;\n    const strictGroups = (this.validatorOptions && this.validatorOptions.strictGroups) || false;\n    const always = (this.validatorOptions && this.validatorOptions.always) || false;\n\n    const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(\n      object.constructor,\n      targetSchema,\n      always,\n      strictGroups,\n      groups\n    );\n    const groupedMetadatas = this.metadataStorage.groupByPropertyName(targetMetadatas);\n\n    if (this.validatorOptions && this.validatorOptions.forbidUnknownValues && !targetMetadatas.length) {\n      const validationError = new ValidationError();\n\n      if (\n        !this.validatorOptions ||\n        !this.validatorOptions.validationError ||\n        this.validatorOptions.validationError.target === undefined ||\n        this.validatorOptions.validationError.target === true\n      )\n        validationError.target = object;\n\n      validationError.value = undefined;\n      validationError.property = undefined;\n      validationError.children = [];\n      validationError.constraints = { unknownValue: 'an unknown value was passed to the validate function' };\n\n      validationErrors.push(validationError);\n\n      return;\n    }\n\n    if (this.validatorOptions && this.validatorOptions.whitelist)\n      this.whitelist(object, groupedMetadatas, validationErrors);\n\n    // General validation\n    Object.keys(groupedMetadatas).forEach(propertyName => {\n      const value = (object as any)[propertyName];\n      const definedMetadatas = groupedMetadatas[propertyName].filter(\n        metadata => metadata.type === ValidationTypes.IS_DEFINED\n      );\n      const metadatas = groupedMetadatas[propertyName].filter(\n        metadata => metadata.type !== ValidationTypes.IS_DEFINED && metadata.type !== ValidationTypes.WHITELIST\n      );\n\n      if (\n        value instanceof Promise &&\n        metadatas.find(metadata => metadata.type === ValidationTypes.PROMISE_VALIDATION)\n      ) {\n        this.awaitingPromises.push(\n          value.then(resolvedValue => {\n            this.performValidations(object, resolvedValue, propertyName, definedMetadatas, metadatas, validationErrors);\n          })\n        );\n      } else {\n        this.performValidations(object, value, propertyName, definedMetadatas, metadatas, validationErrors);\n      }\n    });\n  }\n\n  whitelist(\n    object: any,\n    groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n    validationErrors: ValidationError[]\n  ): void {\n    const notAllowedProperties: string[] = [];\n\n    Object.keys(object).forEach(propertyName => {\n      // does this property have no metadata?\n      if (!groupedMetadatas[propertyName] || groupedMetadatas[propertyName].length === 0)\n        notAllowedProperties.push(propertyName);\n    });\n\n    if (notAllowedProperties.length > 0) {\n      if (this.validatorOptions && this.validatorOptions.forbidNonWhitelisted) {\n        // throw errors\n        notAllowedProperties.forEach(property => {\n          const validationError: ValidationError = this.generateValidationError(object, object[property], property);\n          validationError.constraints = { [ValidationTypes.WHITELIST]: `property ${property} should not exist` };\n          validationError.children = undefined;\n          validationErrors.push(validationError);\n        });\n      } else {\n        // strip non allowed properties\n        notAllowedProperties.forEach(property => delete object[property]);\n      }\n    }\n  }\n\n  stripEmptyErrors(errors: ValidationError[]): ValidationError[] {\n    return errors.filter(error => {\n      if (error.children) {\n        error.children = this.stripEmptyErrors(error.children);\n      }\n\n      if (Object.keys(error.constraints).length === 0) {\n        if (error.children.length === 0) {\n          return false;\n        } else {\n          delete error.constraints;\n        }\n      }\n\n      return true;\n    });\n  }\n\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n\n  private performValidations(\n    object: any,\n    value: any,\n    propertyName: string,\n    definedMetadatas: ValidationMetadata[],\n    metadatas: ValidationMetadata[],\n    validationErrors: ValidationError[]\n  ): void {\n    const customValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.CUSTOM_VALIDATION);\n    const nestedValidationMetadatas = metadatas.filter(metadata => metadata.type === ValidationTypes.NESTED_VALIDATION);\n    const conditionalValidationMetadatas = metadatas.filter(\n      metadata => metadata.type === ValidationTypes.CONDITIONAL_VALIDATION\n    );\n\n    const validationError = this.generateValidationError(object, value, propertyName);\n    validationErrors.push(validationError);\n\n    const canValidate = this.conditionalValidations(object, value, conditionalValidationMetadatas);\n    if (!canValidate) {\n      return;\n    }\n\n    // handle IS_DEFINED validation type the special way - it should work no matter skipUndefinedProperties/skipMissingProperties is set or not\n    this.customValidations(object, value, definedMetadatas, validationError);\n    this.mapContexts(object, value, definedMetadatas, validationError);\n\n    if (value === undefined && this.validatorOptions && this.validatorOptions.skipUndefinedProperties === true) {\n      return;\n    }\n\n    if (value === null && this.validatorOptions && this.validatorOptions.skipNullProperties === true) {\n      return;\n    }\n\n    if (\n      (value === null || value === undefined) &&\n      this.validatorOptions &&\n      this.validatorOptions.skipMissingProperties === true\n    ) {\n      return;\n    }\n\n    this.customValidations(object, value, customValidationMetadatas, validationError);\n    this.nestedValidations(value, nestedValidationMetadatas, validationError.children);\n\n    this.mapContexts(object, value, metadatas, validationError);\n    this.mapContexts(object, value, customValidationMetadatas, validationError);\n  }\n\n  private generateValidationError(object: object, value: any, propertyName: string): ValidationError {\n    const validationError = new ValidationError();\n\n    if (\n      !this.validatorOptions ||\n      !this.validatorOptions.validationError ||\n      this.validatorOptions.validationError.target === undefined ||\n      this.validatorOptions.validationError.target === true\n    )\n      validationError.target = object;\n\n    if (\n      !this.validatorOptions ||\n      !this.validatorOptions.validationError ||\n      this.validatorOptions.validationError.value === undefined ||\n      this.validatorOptions.validationError.value === true\n    )\n      validationError.value = value;\n\n    validationError.property = propertyName;\n    validationError.children = [];\n    validationError.constraints = {};\n\n    return validationError;\n  }\n\n  private conditionalValidations(object: object, value: any, metadatas: ValidationMetadata[]): ValidationMetadata[] {\n    return metadatas\n      .map(metadata => metadata.constraints[0](object, value))\n      .reduce((resultA, resultB) => resultA && resultB, true);\n  }\n\n  private customValidations(object: object, value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    metadatas.forEach(metadata => {\n      this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls).forEach(customConstraintMetadata => {\n        if (customConstraintMetadata.async && this.ignoreAsyncValidations) return;\n        if (\n          this.validatorOptions &&\n          this.validatorOptions.stopAtFirstError &&\n          Object.keys(error.constraints || {}).length > 0\n        )\n          return;\n\n        const validationArguments: ValidationArguments = {\n          targetName: object.constructor ? (object.constructor as any).name : undefined,\n          property: metadata.propertyName,\n          object: object,\n          value: value,\n          constraints: metadata.constraints,\n        };\n\n        if (!metadata.each || !(value instanceof Array || value instanceof Set || value instanceof Map)) {\n          const validatedValue = customConstraintMetadata.instance.validate(value, validationArguments);\n          if (isPromise(validatedValue)) {\n            const promise = validatedValue.then(isValid => {\n              if (!isValid) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            });\n            this.awaitingPromises.push(promise);\n          } else {\n            if (!validatedValue) {\n              const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n              error.constraints[type] = message;\n            }\n          }\n\n          return;\n        }\n\n        // convert set and map into array\n        const arrayValue = convertToArray(value);\n        // Validation needs to be applied to each array item\n        const validatedSubValues = arrayValue.map((subValue: any) =>\n          customConstraintMetadata.instance.validate(subValue, validationArguments)\n        );\n        const validationIsAsync = validatedSubValues.some((validatedSubValue: boolean | Promise<boolean>) =>\n          isPromise(validatedSubValue)\n        );\n\n        if (validationIsAsync) {\n          // Wrap plain values (if any) in promises, so that all are async\n          const asyncValidatedSubValues = validatedSubValues.map((validatedSubValue: boolean | Promise<boolean>) =>\n            isPromise(validatedSubValue) ? validatedSubValue : Promise.resolve(validatedSubValue)\n          );\n          const asyncValidationIsFinishedPromise = Promise.all(asyncValidatedSubValues).then(\n            (flatValidatedValues: boolean[]) => {\n              const validationResult = flatValidatedValues.every((isValid: boolean) => isValid);\n              if (!validationResult) {\n                const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n                error.constraints[type] = message;\n                if (metadata.context) {\n                  if (!error.contexts) {\n                    error.contexts = {};\n                  }\n                  error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n                }\n              }\n            }\n          );\n\n          this.awaitingPromises.push(asyncValidationIsFinishedPromise);\n\n          return;\n        }\n\n        const validationResult = validatedSubValues.every((isValid: boolean) => isValid);\n        if (!validationResult) {\n          const [type, message] = this.createValidationError(object, value, metadata, customConstraintMetadata);\n          error.constraints[type] = message;\n        }\n      });\n    });\n  }\n\n  private nestedValidations(value: any, metadatas: ValidationMetadata[], errors: ValidationError[]): void {\n    if (value === void 0) {\n      return;\n    }\n\n    metadatas.forEach(metadata => {\n      if (metadata.type !== ValidationTypes.NESTED_VALIDATION && metadata.type !== ValidationTypes.PROMISE_VALIDATION) {\n        return;\n      }\n\n      if (value instanceof Array || value instanceof Set || value instanceof Map) {\n        // Treats Set as an array - as index of Set value is value itself and it is common case to have Object as value\n        const arrayLikeValue = value instanceof Set ? Array.from(value) : value;\n        arrayLikeValue.forEach((subValue: any, index: any) => {\n          this.performValidations(value, subValue, index.toString(), [], metadatas, errors);\n        });\n      } else if (value instanceof Object) {\n        const targetSchema = typeof metadata.target === 'string' ? metadata.target : metadata.target.name;\n        this.execute(value, targetSchema, errors);\n      } else {\n        const error = new ValidationError();\n        error.value = value;\n        error.property = metadata.propertyName;\n        error.target = metadata.target as object;\n        const [type, message] = this.createValidationError(metadata.target as object, value, metadata);\n        error.constraints = {\n          [type]: message,\n        };\n        errors.push(error);\n      }\n    });\n  }\n\n  private mapContexts(object: object, value: any, metadatas: ValidationMetadata[], error: ValidationError): void {\n    return metadatas.forEach(metadata => {\n      if (metadata.context) {\n        let customConstraint;\n        if (metadata.type === ValidationTypes.CUSTOM_VALIDATION) {\n          const customConstraints = this.metadataStorage.getTargetValidatorConstraints(metadata.constraintCls);\n          customConstraint = customConstraints[0];\n        }\n\n        const type = this.getConstraintType(metadata, customConstraint);\n\n        if (error.constraints[type]) {\n          if (!error.contexts) {\n            error.contexts = {};\n          }\n\n          error.contexts[type] = Object.assign(error.contexts[type] || {}, metadata.context);\n        }\n      }\n    });\n  }\n\n  private createValidationError(\n    object: object,\n    value: any,\n    metadata: ValidationMetadata,\n    customValidatorMetadata?: ConstraintMetadata\n  ): [string, string] {\n    const targetName = object.constructor ? (object.constructor as any).name : undefined;\n    const type = this.getConstraintType(metadata, customValidatorMetadata);\n    const validationArguments: ValidationArguments = {\n      targetName: targetName,\n      property: metadata.propertyName,\n      object: object,\n      value: value,\n      constraints: metadata.constraints,\n    };\n\n    let message = metadata.message || '';\n    if (\n      !metadata.message &&\n      (!this.validatorOptions || (this.validatorOptions && !this.validatorOptions.dismissDefaultMessages))\n    ) {\n      if (customValidatorMetadata && customValidatorMetadata.instance.defaultMessage instanceof Function) {\n        message = customValidatorMetadata.instance.defaultMessage(validationArguments);\n      }\n    }\n\n    const messageString = ValidationUtils.replaceMessageSpecialTokens(message, validationArguments);\n    return [type, messageString];\n  }\n\n  private getConstraintType(metadata: ValidationMetadata, customValidatorMetadata?: ConstraintMetadata): string {\n    const type = customValidatorMetadata && customValidatorMetadata.name ? customValidatorMetadata.name : metadata.type;\n    return type;\n  }\n}\n"],
  "mappings": "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",
  "names": ["validationResult"]
}

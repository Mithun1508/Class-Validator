{
  "version": 3,
  "sources": ["../../../../class-validator/src/metadata/MetadataStorage.ts"],
  "sourcesContent": ["import { ValidationMetadata } from './ValidationMetadata';\nimport { ConstraintMetadata } from './ConstraintMetadata';\nimport { ValidationSchema } from '../validation-schema/ValidationSchema';\nimport { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Private properties\n  // -------------------------------------------------------------------------\n\n  private validationMetadatas: ValidationMetadata[] = [];\n  private constraintMetadatas: ConstraintMetadata[] = [];\n\n  get hasValidationMetaData(): boolean {\n    return !!this.validationMetadatas.length;\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationSchema(schema: ValidationSchema): void {\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n  }\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationMetadata(metadata: ValidationMetadata): void {\n    this.validationMetadatas.push(metadata);\n  }\n\n  /**\n   * Adds a new constraint metadata.\n   */\n  addConstraintMetadata(metadata: ConstraintMetadata): void {\n    this.constraintMetadatas.push(metadata);\n  }\n\n  /**\n   * Groups metadata by their property names.\n   */\n  groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n    const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n    metadata.forEach(metadata => {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  }\n\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n  getTargetValidationMetadatas(\n    targetConstructor: Function,\n    targetSchema: string,\n    always: boolean,\n    strictGroups: boolean,\n    groups?: string[]\n  ): ValidationMetadata[] {\n    const includeMetadataBecauseOfAlwaysOption = (metadata: ValidationMetadata): boolean => {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always;\n\n      // `metadata.groups` overrides global default.\n      if (metadata.groups && metadata.groups.length) return false;\n\n      // Use global default.\n      return always;\n    };\n\n    const excludeMetadataBecauseOfStrictGroupsOption = (metadata: ValidationMetadata): boolean => {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n\n      return false;\n    };\n\n    // get directly related to a target metadatas\n    const originalMetadatas = this.validationMetadatas.filter(metadata => {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // get metadatas for inherited classes\n    const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))\n        return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n      return !originalMetadatas.find(originalMetadata => {\n        return (\n          originalMetadata.propertyName === inheritedMetadata.propertyName &&\n          originalMetadata.type === inheritedMetadata.type\n        );\n      });\n    });\n\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  }\n\n  /**\n   * Gets all validator constraints for the given object.\n   */\n  getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n    return this.constraintMetadatas.filter(metadata => metadata.target === target);\n  }\n}\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n  const global = getGlobal();\n\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n\n  return global.classValidatorMetadataStorage;\n}\n"],
  "mappings": "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",
  "names": ["metadata"]
}

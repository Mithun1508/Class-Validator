{
  "version": 3,
  "sources": ["../../../class-validator/src/register-decorator.ts"],
  "sourcesContent": ["import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidatorConstraintInterface } from './validation/ValidatorConstraintInterface';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from './metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { ValidationArguments } from './validation/ValidationArguments';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\nimport { ValidationOptions } from './decorator/ValidationOptions';\n\nexport interface ValidationDecoratorOptions {\n  /**\n   * Target object to be validated.\n   */\n  target: Function;\n\n  /**\n   * Target object's property name to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Name of the validation that is being registered.\n   */\n  name?: string;\n\n  /**\n   * Indicates if this decorator will perform async validation.\n   */\n  async?: boolean;\n\n  /**\n   * Validator options.\n   */\n  options?: ValidationOptions;\n\n  /**\n   * Array of validation constraints.\n   */\n  constraints?: any[];\n\n  /**\n   * Validator that performs validation.\n   */\n  validator: ValidatorConstraintInterface | Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n  let constraintCls: Function;\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n    if (constraintClasses.length > 1) {\n      throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n    }\n  } else {\n    const validator = options.validator;\n    constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n      validate(value: any, validationArguments?: ValidationArguments): Promise<boolean> | boolean {\n        return validator.validate(value, validationArguments);\n      }\n\n      defaultMessage(validationArguments?: ValidationArguments): string {\n        if (validator.defaultMessage) {\n          return validator.defaultMessage(validationArguments);\n        }\n\n        return '';\n      }\n    };\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n\n  const validationMetadataArgs: ValidationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints,\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gCAAmC;AAEnC,gCAAmC;AAEnC,6BAAgC;AAEhC,uBAAiC;AACjC,6BAAoD;AA2C7C,SAAS,kBAAkB,SAA2C;AAC3E,MAAI;AACJ,MAAI,QAAQ,qBAAqB,UAAU;AACzC,oBAAgB,QAAQ;AACxB,UAAM,wBAAoB,mCAAiB,sCAAe,EAAE,8BAA8B,QAAQ,SAAS;AAC3G,QAAI,kBAAkB,SAAS,GAAG;AAChC,YAAM,wFAAwF,QAAQ,OAAO,QAAQ,QAAQ;AAAA,IAC/H;AAAA,EACF,OAAO;AACL,UAAM,YAAY,QAAQ;AAC1B,oBAAgB,MAAM,iBAAyD;AAAA,MAC7E,SAAS,OAAY,qBAAuE;AAC1F,eAAO,UAAU,SAAS,OAAO,mBAAmB;AAAA,MACtD;AAAA,MAEA,eAAe,qBAAmD;AAChE,YAAI,UAAU,gBAAgB;AAC5B,iBAAO,UAAU,eAAe,mBAAmB;AAAA,QACrD;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AACA,mDAAmB,EAAE,sBAAsB,IAAI,6CAAmB,eAAe,QAAQ,MAAM,QAAQ,KAAK,CAAC;AAAA,EAC/G;AAEA,QAAM,yBAAiD;AAAA,IACrD,MAAM,QAAQ,QAAQ,uCAAgB,QAAQ,QAAQ,IAAI,IAAI,QAAQ,OAAO,uCAAgB;AAAA,IAC7F,QAAQ,QAAQ;AAAA,IAChB,cAAc,QAAQ;AAAA,IACtB,mBAAmB,QAAQ;AAAA,IAC3B;AAAA,IACA,aAAa,QAAQ;AAAA,EACvB;AACA,iDAAmB,EAAE,sBAAsB,IAAI,6CAAmB,sBAAsB,CAAC;AAC3F;",
  "names": []
}
